---
title: 【Codeforces-660E】Different Subsets For All Tuples
publishDate: 2021-11-11
description: '来自 zyc 的组合数学好题。'
tags:
  - oi_solution

language: '中文'
---

# 题意

一个整数数列，每个元素在 $[1, m]$ 上取值，共有 $m^n$ 种可能的数列。

对每个数列，分别求出其中本质不同的子序列个数，然后求和，包括空序列。

对 $10^9+7$ 取模，$1\leq n,m\leq 10^6$.

# 分析

首先考虑空序列，每种数列均有 $1$ 个，共有 $\operatorname{Ans}_1 = m^n$ 个。

对于非空子序列。考虑固定一个非空子序列，统计包含它的原串个数。

不妨设其在原序列中的出现位置为 $p_1, p_2, \cdots, p_i$，每个位置上的数值为 $x_1, x_2, \cdots, x_i$.

为了避免重复，若子序列在原序列中出现多次，则钦定 $p_1\cdots p_i$ 为第一次出现的位置，也就是说，钦定 $p_1\cdots p_i$ 的字典序最小。

这意味着，$1\sim p_1-1$ 不能出现 $x_1$，$p_1+1\sim p_2-1$ 中不能出现 $x_2$，依次类推，每个 $p$ 都是最靠前的位置。

开始组合方法推式子，容易得到：
$$
\operatorname{Ans}_2 = \sum_{i=1}^{n}m^i\sum_{j=i}^{n}{C_{j-1}^{i-1}(m-1)^{j-i}m^{n-j}}
$$
其中 $i$ 枚举子序列长度，$j$ 枚举子序列最后一个元素的出现位置；

$m^i$ 为子序列可能的取值数量；$C_{j-1}^{i-1}$ 统计 $p_1\cdots p_n$ 的可能情况数量；

$(m-1)^{j-i}$ 是填子序列之间的空隙的方法数量；$m^{n-j}$ 代表最后的 $n-j$ 位可以任取。

现在我们要在 $\mathcal{O}(n)$ 或 $\mathcal{O}(n\log n)$ 的复杂度求出 $\operatorname{Ans}$ 的值，考虑下面的转化。

合并同类项，
$$
\operatorname{Ans}_2 = \sum_{i=1}^{n}\sum_{j=i}^{n}{C_{j-1}^{i-1}(m-1)^{j-i}m^{n-j+i}}
$$
组合数 $C_{j-1}^{i-1}$ 很难处理，考虑二项式定理的形式 $(a+b)^n=\sum\limits_{i=0}^{n}C_n^i\cdot a^i b^{n-i}$ 中，组合数下面的 $n$ 要和 $\sum$ 相同。

因此，变化 $\sum$ 的形式，并交换两个求和符号，往二项式定理方向转化：
$$
\begin{aligned}
\operatorname{Ans}_2 &= \sum_{i=1}^{n}\sum_{j=i}^{n}{C_{j-1}^{i-1}(m-1)^{j-i}m^{n-j+i}}\\
&= \sum_{i=0}^{n-1}\sum_{j=0}^{n-1}C_j^i(m-1)^{j-i}m^{n-j+i}\\
&= \sum_{j=0}^{n-1}\sum_{i=0}^{j}C_j^i(m-1)^{j-i}m^{n+i-j}
\end{aligned}
$$
二项式定理中，两个指数的和为定值，所以：
$$
\begin{aligned}
\operatorname{Ans}_2 &= \sum_{j=0}^{n-1}\sum_{i=0}^{j}C_j^i(m-1)^{j-i}m^{n+i-j}\\
&= \sum_{j=0}^{n-1}m^{n-j}\sum_{i=0}^{j}C_j^i(m-1)^{j-i}m^{i}\\
&= \sum_{j=0}^{n-1}m^{n-j}[(m-1)+m]^{j}\\
&= \sum_{j=0}^{n-1}m^{n-j}(2m-1)^{j}\\
\end{aligned}
$$
这个可以在 $\mathcal{O}(n)$ 时间复杂度内求出，最终答案的形式为：
$$
\operatorname{Ans}=\textcolor{gray}{\operatorname{Ans}_1+\operatorname{Ans}_2}=m^n+\sum_{j=0}^{n-1}m^{n-j}(2m-1)^{j}
$$

# 代码

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int MAXN = 1e6 + 10, mod = 1e9 + 7;
int n, m, ans, Pow1[MAXN] = {1}, Pow2[MAXN] = {1};
signed main() {
	scanf("%lld%lld", &n, &m);
	for(int i = 1; i <= n; i++) 
        Pow1[i] = Pow1[i - 1] * m % mod, Pow2[i] = Pow2[i - 1] * (2 * m - 1) % mod;
	for(int i = 0; i < n; i++) 
        ans = (ans + Pow1[n - i] * Pow2[i] % mod) % mod;
	printf("%lld\n", (ans + Pow1[n]) % mod) ;
	return 0;
}
```